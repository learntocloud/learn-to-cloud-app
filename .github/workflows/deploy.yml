name: Deploy to Azure

on:
  push:
    branches: [main]
    paths-ignore:
      - 'infra/**'       # Infra changes handled by infra.yml
      - '*.md'           # Docs don't need deploy
      - 'docs/**'
      - '.github/instructions/**'
      - '.github/skills/**'
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild without cache (for security updates)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      deploy_api:
        description: 'Deploy API'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      deploy_frontend:
        description: 'Deploy Frontend'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
  workflow_call:
    inputs:
      force_rebuild:
        description: 'Force rebuild without cache'
        required: false
        default: false
        type: boolean

concurrency:
  group: deploy-${{ vars.AZURE_ENV_NAME }}
  cancel-in-progress: false

permissions:
  contents: read

defaults:
  run:
    shell: bash

env:
  AZURE_ENV_NAME: ${{ vars.AZURE_ENV_NAME }}
  AZURE_LOCATION: ${{ vars.AZURE_LOCATION }}
  AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
  TF_VAR_environment: ${{ vars.AZURE_ENV_NAME }}
  TF_VAR_location: ${{ vars.AZURE_LOCATION }}
  TF_VAR_frontend_custom_domain: ${{ vars.FRONTEND_CUSTOM_DOMAIN == 'none' && '' || vars.FRONTEND_CUSTOM_DOMAIN }}
  ARM_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
  ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
  ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}

jobs:
  # Detect which paths changed
  changes:
    runs-on: ubuntu-latest
    outputs:
      api: ${{ steps.filter.outputs.api }}
      frontend: ${{ steps.filter.outputs.frontend }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            api:
              - 'api/**'
              - 'content/**'
            frontend:
              - 'frontend/**'

  terraform:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    defaults:
      run:
        working-directory: infra
    outputs:
      api_container_app_name: ${{ steps.tf-outputs.outputs.api_container_app_name }}
      resource_group_name: ${{ steps.tf-outputs.outputs.resource_group_name }}
      container_registry_name: ${{ steps.tf-outputs.outputs.container_registry_name }}
      container_registry_endpoint: ${{ steps.tf-outputs.outputs.container_registry_endpoint }}
      api_url: ${{ steps.tf-outputs.outputs.api_url }}
      frontend_url: ${{ steps.tf-outputs.outputs.frontend_url }}
      frontend_custom_domain: ${{ steps.tf-outputs.outputs.frontend_custom_domain }}
      swa_name: ${{ steps.tf-outputs.outputs.swa_name }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~1.5"
          terraform_wrapper: false

      - name: Azure CLI Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Terraform Init
        run: terraform init

      - name: Terraform Validate
        run: terraform validate

      - name: Get Terraform Outputs
        id: tf-outputs
        run: |
          echo "api_container_app_name=ca-ltc-api-${{ vars.AZURE_ENV_NAME }}" >> "$GITHUB_OUTPUT"
          echo "resource_group_name=$(terraform output -raw AZURE_RESOURCE_GROUP)" >> "$GITHUB_OUTPUT"
          echo "container_registry_name=$(terraform output -raw AZURE_CONTAINER_REGISTRY_NAME)" >> "$GITHUB_OUTPUT"
          echo "container_registry_endpoint=$(terraform output -raw AZURE_CONTAINER_REGISTRY_ENDPOINT)" >> "$GITHUB_OUTPUT"
          echo "api_url=$(terraform output -raw apiUrl)" >> "$GITHUB_OUTPUT"
          echo "frontend_url=$(terraform output -raw frontend_url)" >> "$GITHUB_OUTPUT"
          CUSTOM_DOMAIN="${{ vars.FRONTEND_CUSTOM_DOMAIN }}"
          if [[ "$CUSTOM_DOMAIN" == "none" ]]; then CUSTOM_DOMAIN=""; fi
          echo "frontend_custom_domain=$CUSTOM_DOMAIN" >> "$GITHUB_OUTPUT"
          echo "swa_name=$(terraform output -raw swa_name)" >> "$GITHUB_OUTPUT"

  deploy-api:
    needs: [changes, terraform]
    if: |
      (needs.changes.outputs.api == 'true' || github.event_name == 'workflow_dispatch') &&
      (github.event_name != 'workflow_dispatch' || inputs.deploy_api == 'true')
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4

      - name: Azure CLI Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Log in to ACR
        run: az acr login --name ${{ needs.terraform.outputs.container_registry_name }}

      - name: Set build flags
        id: build-flags
        run: |
          FORCE_REBUILD="${{ inputs.force_rebuild }}"
          if [[ "$FORCE_REBUILD" == "true" ]]; then
            echo "cache_flags=--no-cache --pull" >> "$GITHUB_OUTPUT"
            echo "use_cache=false" >> "$GITHUB_OUTPUT"
          else
            echo "cache_flags=" >> "$GITHUB_OUTPUT"
            echo "use_cache=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Pull existing image for cache
        if: steps.build-flags.outputs.use_cache == 'true'
        continue-on-error: true
        run: docker pull ${{ needs.terraform.outputs.container_registry_endpoint }}/api:latest || true

      - name: Build and Push API Image
        run: |
          CACHE_FROM=""
          if [[ "${{ steps.build-flags.outputs.use_cache }}" == "true" ]]; then
            CACHE_FROM="--cache-from=${{ needs.terraform.outputs.container_registry_endpoint }}/api:latest"
          fi
          docker build -f api/Dockerfile \
            ${{ steps.build-flags.outputs.cache_flags }} \
            $CACHE_FROM \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            --label git-commit=${{ github.sha }} \
            --label git-branch=${{ github.ref_name }} \
            -t ${{ needs.terraform.outputs.container_registry_endpoint }}/api:${{ github.sha }} \
            -t ${{ needs.terraform.outputs.container_registry_endpoint }}/api:latest .
          docker push ${{ needs.terraform.outputs.container_registry_endpoint }}/api:${{ github.sha }}
          docker push ${{ needs.terraform.outputs.container_registry_endpoint }}/api:latest

      - name: Start PostgreSQL for Smoke Test
        run: |
          docker run --rm -d --name smoke-test-db \
            -e POSTGRES_USER=postgres \
            -e POSTGRES_PASSWORD=postgres \
            -e POSTGRES_DB=learntocloud \
            -p 5432:5432 \
            postgres:16-alpine
          sleep 5

      - name: Smoke Test API Image
        run: |
          docker run --rm -d --name smoke-test -p 8000:8000 \
            --link smoke-test-db:db \
            -e DATABASE_URL=postgresql+asyncpg://postgres:postgres@db:5432/learntocloud \
            -e CLERK_SECRET_KEY=test \
            -e LLM_API_KEY=test \
            ${{ needs.terraform.outputs.container_registry_endpoint }}/api:${{ github.sha }}
          sleep 10
          curl -f http://localhost:8000/health || (docker logs smoke-test && exit 1)
          docker stop smoke-test
          docker stop smoke-test-db

      - name: Install Trivy
        run: |
          sudo apt-get install -y wget apt-transport-https gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/trivy.list
          sudo apt-get update && sudo apt-get install -y trivy

      - name: Security Scan API Image
        run: |
          trivy image --ignore-unfixed --exit-code 1 --severity HIGH,CRITICAL \
            ${{ needs.terraform.outputs.container_registry_endpoint }}/api:${{ github.sha }} || \
            echo "::warning::Trivy found vulnerabilities. Review the scan results above."

      - name: Deploy API Container App
        run: |
          FRONTEND_URL="${{ needs.terraform.outputs.frontend_url }}"
          if [[ -n "${{ needs.terraform.outputs.frontend_custom_domain }}" ]]; then
            FRONTEND_URL="https://${{ needs.terraform.outputs.frontend_custom_domain }}"
          fi
          az containerapp update \
            --name ${{ needs.terraform.outputs.api_container_app_name }} \
            --resource-group ${{ needs.terraform.outputs.resource_group_name }} \
            --image ${{ needs.terraform.outputs.container_registry_endpoint }}/api:${{ github.sha }} \
            --set-env-vars FRONTEND_URL="$FRONTEND_URL" RUN_MIGRATIONS_ON_STARTUP=true

      - name: Wait for API readiness
        run: |
          READY_URL="${{ needs.terraform.outputs.api_url }}/ready"
          echo "Waiting for API readiness at: $READY_URL"
          for i in {1..30}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "$READY_URL" || true)
            if [[ "$code" == "200" ]]; then
              echo "API is ready."
              exit 0
            fi
            echo "Attempt $i: HTTP $code, retrying in 10s..."
            sleep 10
          done
          echo "API did not become ready."
          exit 1

  deploy-frontend:
    needs: [changes, terraform]
    if: |
      (needs.changes.outputs.frontend == 'true' || github.event_name == 'workflow_dispatch') &&
      (github.event_name != 'workflow_dispatch' || inputs.deploy_frontend == 'true')
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: frontend
        run: npm ci

      - name: Build frontend
        working-directory: frontend
        run: npm run build
        env:
          VITE_API_URL: ""
          VITE_CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
          VITE_CLERK_PROXY_URL: "${{ needs.terraform.outputs.frontend_url }}/.clerk"

      - name: Copy staticwebapp.config.json
        run: cp frontend/staticwebapp.config.json frontend/dist/

      - name: Deploy to Azure Static Web Apps
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ secrets.SWA_DEPLOYMENT_TOKEN }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          action: "upload"
          app_location: "frontend/dist"
          output_location: ""
          skip_app_build: true
          skip_api_build: true

# =============================================================================
# NOTES
# =============================================================================
# This workflow deploys to Azure when code is pushed to main.
#
# Path-based deployment:
#   - api/** or content/** changes → deploy-api job runs
#   - frontend/** changes → deploy-frontend job runs
#   - Both can run in parallel
#   - workflow_dispatch allows manual control of what to deploy
#
# CI is handled by separate workflows:
#   - api-ci.yml: Runs on api/** changes (lint, type check, unit tests)
#   - frontend-ci.yml: Runs on frontend/** changes (lint, tests, build)
#
# Infrastructure:
#   - infra/** changes trigger infra.yml instead (paths-ignore)
#   - This workflow reads Terraform outputs but doesn't apply changes
# =============================================================================
