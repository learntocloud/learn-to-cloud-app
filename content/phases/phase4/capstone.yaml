id: phase4-topic9
slug: capstone
name: 'Capstone: Cloud Deployment'
description: Deploy the Journal API you built in Phase 3 to a secure 2-tier cloud architecture. This capstone challenges you to research, design, and implement a production-ready environment with proper networking and security, using the database and deployment preparation work you completed in earlier Phase 4 topics. You must have all Phase 3 endpoints implemented (GET single entry, DELETE single entry, and AI analysis) before starting.
short_description: Deploy your completed Journal API to a secure 2-tier cloud architecture with VMs, networking, and HTTPS.
order: 9
learning_objectives:
- id: cloud-capstone-architecture
  text: Design a secure two-tier cloud architecture for API and database workloads.
  order: 1
- id: cloud-capstone-implementation
  text: Implement networking, compute, and database components to run the Journal API end to end.
  order: 2
- id: cloud-capstone-cloud-ai
  text: Deploy and integrate a cloud-hosted AI model with your application.
  order: 3
- id: cloud-capstone-verification
  text: Validate deployment success criteria including HTTPS, connectivity controls, and functional API behavior.
  order: 4
learning_steps:
- order: 1
  action: 'Explore:'
  title: Design your 2-tier architecture
  description: Use your **Database Deployment & Configuration** topic work as input. Sketch your infrastructure on paper or a diagram before touching the cloud console.
  checklist:
    - A virtual network with a CIDR range (e.g., `10.0.0.0/16`)
    - A **public subnet** for the API (e.g., `10.0.1.0/24`)
    - A **private subnet** for the database (e.g., `10.0.2.0/24`)
    - Firewall rules for each subnet, including **SSH (22)** for management access — not just application ports
    - "The traffic flow: Internet → port 443 (reverse proxy) → port 8000 (your application) → port 5432 (database)"
    - How you will manage the private VM (e.g., SSH through the public VM as a jump box, since the database VM has no public IP)
  tips:
    - type: tip
      text: If your cloud platform requires approval for AI model access (e.g., Azure OpenAI, AWS Bedrock), request it now — approval can take days and will block Step 6.
    - type: note
      text: On some cloud platforms, subnets are not inherently "public" or "private" — visibility depends on whether a VM has a public IP and what the firewall rules allow.
  done_when: You have a diagram showing public subnet (API), private subnet (database), CIDR ranges, firewall rules including SSH access, and the port chain from internet to database.
  id: phase4-topic9-explore-design-your-2-tier-architecture

- order: 2
  action: 'Practice:'
  title: Create your virtual network with public and private subnets
  description: Create a virtual network with at least two subnets — one public (API) and one private (database). Create security groups or firewall rules for each.
  checklist:
    - "**Public subnet** — allow inbound SSH (22), HTTP (80), and HTTPS (443) from the internet"
    - "**Private subnet** — allow inbound PostgreSQL (5432) and SSH (22) **only from the public subnet's CIDR range**. Deny all other inbound from the internet"
    - Associate each security group with its respective subnet
    - Verify outbound internet access is allowed for both subnets (needed for package installation — most platforms allow this by default)
  done_when: Both subnets exist, security groups are associated with them, and your firewall rules match the design from Step 1.
  id: phase4-topic9-practice-create-your-virtual-network

- order: 3
  action: 'Practice:'
  title: Deploy the database in the private subnet
  description: Deploy a VM in the private subnet, install PostgreSQL, create the `career_journal` database with a dedicated user, and run your schema migration.
  checklist:
    - "**Provision the VM** — Create in the private subnet with a **temporary public IP** and a temporary SSH firewall rule (needed for initial setup)"
    - "**Install PostgreSQL**"
    - "**Create the database** and a dedicated user"
    - "**Run the schema** — Execute `database_setup.sql` from your repository to create the `entries` table and indexes"
    - "**Grant permissions** — If you ran the schema as the `postgres` superuser, your app user won't have access without explicit `GRANT` statements on the schema and tables"
    - "**Configure remote access** — Modify `postgresql.conf` (set `listen_addresses`) and `pg_hba.conf` (allow your API subnet)"
    - "**Restart PostgreSQL**"
    - "**Save connection details** — Private IP, username, password, and database name for building `DATABASE_URL` in the next step"
  tips:
    - type: tip
      text: The DB VM needs outbound internet to install packages — use a temporary public IP (remove after) or a managed NAT service. If your VM has ≤1 GiB RAM, configure swap space (2 GiB recommended) or PostgreSQL may be killed by the OOM handler.
  done_when: You can connect to PostgreSQL from the API subnet via private IP, your dedicated user can read and write the `entries` table, and the database is **not** reachable from the internet.
  id: phase4-topic9-practice-deploy-the-database-in

- order: 4
  action: 'Practice:'
  title: Deploy the API server and connect to the database
  description: Deploy a VM in the public subnet, install the Journal API, and connect it to the database using the DB VM's **private IP address**.
  checklist:
    - "**Provision the VM** — Create in the public subnet with a public IP"
    - "**Clone your repo** onto the VM"
    - "**Install `uv`** — `curl -LsSf https://astral.sh/uv/install.sh | sh`, then `uv sync`"
    - "**Configure the database connection** — Create `.env` with `DATABASE_URL=postgresql://youruser:yourpassword@db-private-ip:5432/career_journal`"
    - "**Run as a background service** (e.g., systemd) — set `PYTHONPATH` to your project dir, include `uv` in `PATH`, entry point: `uv run uvicorn api.main:app --host 0.0.0.0 --port 8000`. Do **not** use `--reload` in production"
    - "**Smoke test** — `curl http://localhost:8000/entries`"
  tips:
    - type: tip
      text: The Journal API requires Python 3.11+. Ubuntu 24.04 LTS ships Python 3.12 — older images may need a separate install. If your VM has ≤1 GiB RAM, configure swap space (2 GiB recommended).
  done_when: "All CRUD operations work from the VM — `POST /entries`, `GET /entries`, `GET /entries/{id}`, `PATCH /entries/{id}`, and `DELETE /entries/{id}`."
  id: phase4-topic9-practice-deploy-the-api-server

- order: 5
  action: 'Practice:'
  title: Expose your API over HTTPS
  description: Set up a **domain name** pointing to your VM's public IP, obtain a **TLS certificate**, and configure a **reverse proxy** to terminate TLS and forward traffic to `localhost:8000`.
  checklist:
    - "**Domain name** — Create an A record pointing to your VM's public IP. Use a registrar, free DNS service, or your cloud platform's DNS features"
    - "**Reverse proxy** — Install **Nginx** or **Caddy**. Configure to forward requests to `http://127.0.0.1:8000`"
    - "**TLS certificate** — Use **Let's Encrypt** with **Certbot** (Nginx) or Caddy's built-in auto-TLS"
  tips:
    - type: warning
      text: The automated verifier does **not** follow HTTP redirects. Ensure `GET /entries` on your HTTPS URL returns a direct `200 OK`, not a `3xx` redirect. Watch for trailing-slash behavior — FastAPI redirects `/entries/` to `/entries` with a 307. Use `/entries` (no trailing slash).
  done_when: "`curl -v https://yourdomain/entries` returns valid JSON with a trusted certificate, a 200 status code, and no redirects."
  id: phase4-topic9-practice-expose-your-api-over-https

- order: 6
  action: 'Practice:'
  title: Deploy and switch your Journal API to cloud AI
  description: Deploy or provision access to an LLM on your cloud platform. Your Journal API's AI integration lives in `api/services/llm_service.py` and uses the `openai` Python package.
  checklist:
    - "**Option A — OpenAI-compatible endpoint:** Update `OPENAI_BASE_URL`, `OPENAI_API_KEY`, and `OPENAI_MODEL` in `.env`"
    - "**Option B — Provider-specific SDK:** Modify the client creation in `llm_service.py` to use your provider's client class. Check your provider's docs for integration"
    - "**Redeploy** — Push changes to the VM and restart your service"
  done_when: "`curl -X POST https://yourdomain/entries/{id}/analyze` returns sentiment, summary, and topics from your cloud-hosted model."
  id: phase4-topic9-practice-deploy-and-switch-your

- order: 7
  action: 'Practice:'
  title: Verify and submit your deployment
  description: Submit your HTTPS base URL (e.g., `https://your-api.example.com`). The verifier POSTs a challenge entry to `/entries`, confirms it appears in `GET /entries`, then deletes it.
  tips:
    - type: tip
      text: Your API's response format must match the data schema defined in the journal-starter README. Your API must respond within 15 seconds.
  done_when: The verifier shows "Deployed API verified!"
  id: phase4-topic9-practice-verify-and-submit-your

- order: 8
  action: 'Practice:'
  title: Clean up your cloud resources
  description: Delete all cloud resources you provisioned. Check your cloud console to confirm nothing is still running or incurring charges.
  checklist:
    - VMs, disks, and public IPs
    - Virtual networks, subnets, and security groups
    - AI resources and deployments
    - Temporary public IP and SSH rule from the database VM
  tips:
    - type: tip
      text: If your cloud platform supports resource groups or tagging, use them — deleting a single group or filtering by tag makes cleanup straightforward.
  id: phase4-topic9-practice-clean-up-your-cloud

- order: 9
  action: 'Reflect:'
  title: Share your progress
  description: Push your work to GitHub and write a brief technical writeup covering your architecture decisions, what networking and security controls you implemented, and what you'd do differently. Share it on LinkedIn or with the Learn to Cloud community to get feedback and celebrate your progress.
  id: phase4-topic9-reflect-share-your-progress
